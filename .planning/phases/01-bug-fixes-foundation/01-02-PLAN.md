---
phase: 01-bug-fixes-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - shared/types/entities.ts
  - shared/types/socket-events.ts
  - backend/src/services/room/RoomManager.ts
  - backend/src/handlers/roomHandlers.ts
  - backend/src/server.ts
autonomous: true

must_haves:
  truths:
    - "Server identifies users by persistent clientId, not ephemeral socket.id"
    - "When same clientId reconnects, old socket gets grace period (2.5s) before disconnect"
    - "After reconnection, server pushes full room state snapshot to client"
    - "Simultaneous reconnections (server restart) are batched in 3s window to reduce broadcast storms"
    - "Disconnect handler uses clientId mapping instead of socket.id scan"
  artifacts:
    - path: "shared/types/entities.ts"
      provides: "User type with clientId field"
      contains: "clientId: string"
    - path: "shared/types/socket-events.ts"
      provides: "RoomRejoinRequest and RoomStateSnapshot event types"
      contains: "RoomRejoinRequest"
    - path: "backend/src/services/room/RoomManager.ts"
      provides: "Client connection tracking with grace period and batch reconnection"
      contains: "clientConnections"
    - path: "backend/src/handlers/roomHandlers.ts"
      provides: "room:rejoin handler that sends state snapshot"
      contains: "room:rejoin"
    - path: "backend/src/server.ts"
      provides: "Updated disconnect handler using clientId mapping"
      contains: "clientId"
  key_links:
    - from: "backend/src/handlers/roomHandlers.ts"
      to: "backend/src/services/room/RoomManager.ts"
      via: "roomManager.handleReconnection and roomManager.getFullStateSnapshot"
      pattern: "roomManager\\.handleReconnection"
    - from: "backend/src/handlers/roomHandlers.ts"
      to: "shared/types/socket-events.ts"
      via: "import RoomRejoinRequest"
      pattern: "RoomRejoinRequest"
    - from: "backend/src/services/room/RoomManager.ts"
      to: "shared/types/entities.ts"
      via: "User.clientId field usage"
      pattern: "clientId"
---

<objective>
Fix BUGF-02 backend: Replace ephemeral socket.id-based user identification with persistent clientId tracking, add grace period for old connections, full state snapshot on reconnection, and batch reconnection handling.

Purpose: Socket.io generates new socket IDs on each connection. Using socket.id as identity causes duplicate room members and state loss on reconnection. Per user decision, server must use clientId (persistent UUID from client) for identification.
Output: Backend infrastructure for seamless reconnection without race conditions.
</objective>

<execution_context>
@C:/Users/MiaowFISH/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/MiaowFISH/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-bug-fixes-foundation/01-RESEARCH.md
@.planning/phases/01-bug-fixes-foundation/01-01-SUMMARY.md

@shared/types/entities.ts
@shared/types/socket-events.ts
@backend/src/services/room/RoomManager.ts
@backend/src/handlers/roomHandlers.ts
@backend/src/server.ts
@backend/src/services/sync/SyncEngine.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add clientId to shared types and update RoomManager with connection tracking</name>
  <files>shared/types/entities.ts, shared/types/socket-events.ts, backend/src/services/room/RoomManager.ts</files>
  <action>
1. **shared/types/entities.ts** — Add `clientId` to User interface:
   - Add `clientId: string;` field after `userId` in the `User` interface (this is the persistent UUID generated client-side)

2. **shared/types/socket-events.ts** — Add reconnection event types:
   - Add `RoomRejoinRequest` interface: `{ roomId: string; userId: string; clientId: string; username: string; deviceId: string; deviceType: 'ios' | 'android' | 'web' }`
   - Add `RoomStateSnapshot` interface: `{ room: Room; syncState: SyncState; currentTrack: Track | null; serverTimestamp: number }`
   - Add to `SocketEvents` interface: `'room:rejoin': (data: RoomRejoinRequest) => void;` and `'room:state_snapshot': (data: RoomStateSnapshot) => void;`
   - Add `clientId: string` to `RoomCreateRequest` and `RoomJoinRequest` interfaces

3. **backend/src/services/room/RoomManager.ts** — Add connection tracking infrastructure:
   - Add a `ClientConnection` interface at top: `{ clientId: string; socketId: string; userId: string; roomId: string; connectedAt: number; gracePeriodTimer?: NodeJS.Timeout }`
   - Add private field `clientConnections: Map<string, ClientConnection> = new Map()` to RoomManager class
   - Add private field `GRACE_PERIOD_MS = 2500` (2.5 seconds per research recommendation)
   - Add private field `BATCH_RECONNECT_WINDOW_MS = 3000` (3 seconds)
   - Add private field `pendingReconnections: Map<string, NodeJS.Timeout> = new Map()` for batch reconnection tracking (keyed by roomId)

   - Add method `handleReconnection(clientId: string, newSocketId: string, userId: string, roomId: string, io: any): void`:
     - Look up existing connection by clientId in `clientConnections`
     - If existing connection found:
       - Clear any existing grace period timer
       - Set grace period timer: after 2.5s, disconnect old socket via `io.sockets.sockets.get(oldSocketId)?.disconnect(true)`
       - Update mapping to new socketId immediately
     - If no existing connection, create new entry
     - Update the User's socketId and clientId in the room's member list
     - Schedule batch broadcast: if no pending reconnection timer for this roomId, set one for 3s. When it fires, broadcast updated room state to all members in the room (single broadcast instead of per-reconnection).

   - Add method `getFullStateSnapshot(roomId: string): RoomStateSnapshot | null`:
     - Get room, return null if not found
     - Return `{ room, syncState: room.syncState, currentTrack: room.currentTrack, serverTimestamp: Date.now() }`

   - Add method `findConnectionBySocketId(socketId: string): ClientConnection | undefined`:
     - Iterate clientConnections to find entry matching socketId
     - Used by disconnect handler instead of scanning all rooms

   - Add method `removeConnection(clientId: string): void`:
     - Clear grace period timer if exists
     - Delete from clientConnections map

   - Update `createRoom`: set `clientId` on hostUser from request (add clientId to the User object creation)
   - Update `joinRoom`: set `clientId` on new/reconnecting user from request
  </action>
  <verify>
Run `cd D:\Codespace\musesync && yarn workspace backend type-check` to verify TypeScript compilation. Check that:
- `User` interface has `clientId: string`
- `RoomCreateRequest` and `RoomJoinRequest` have `clientId: string`
- `RoomManager` has `handleReconnection`, `getFullStateSnapshot`, `findConnectionBySocketId`, `removeConnection` methods
  </verify>
  <done>Shared types include clientId field. RoomManager tracks client connections with grace period (2.5s) and batch reconnection (3s window). State snapshot method available for reconnection flow.</done>
</task>

<task type="auto">
  <name>Task 2: Update room handlers and server disconnect logic for clientId-based identification</name>
  <files>backend/src/handlers/roomHandlers.ts, backend/src/server.ts</files>
  <action>
1. **backend/src/handlers/roomHandlers.ts** — Update existing handlers and add rejoin:
   - Import `RoomRejoinRequest` from socket-events

   - Update `room:create` handler: after successful room creation, call `roomManager.handleReconnection(request.clientId, socket.id, request.userId, roomId, socket.server)` to register the connection mapping.

   - Update `room:join` handler: after successful join, call `roomManager.handleReconnection(request.clientId, socket.id, request.userId, roomId, socket.server)` to register the connection mapping.

   - Add `room:rejoin` handler:
     ```
     socket.on('room:rejoin', (request: RoomRejoinRequest, callback) => {
       // Verify room exists
       const room = roomManager.getRoom(request.roomId);
       if (!room) { callback({ success: false, error: 'Room not found' }); return; }

       // Check if user is a member (by userId)
       const member = room.members.find(m => m.userId === request.userId);
       if (!member) { callback({ success: false, error: 'Not a member of this room' }); return; }

       // Handle reconnection (updates socketId, sets grace period for old socket)
       roomManager.handleReconnection(request.clientId, socket.id, request.userId, request.roomId, socket.server);

       // Join Socket.io room
       socket.join(request.roomId);

       // Start heartbeat
       syncEngine.startHeartbeat(request.roomId, request.userId, socket.id);

       // Send full state snapshot
       const snapshot = roomManager.getFullStateSnapshot(request.roomId);
       if (snapshot) {
         socket.emit('room:state_snapshot', snapshot);
       }

       callback({ success: true, room });
     });
     ```

   - Update `disconnect` handler: Replace the current approach (scanning all rooms by socket.id) with:
     - Call `roomManager.findConnectionBySocketId(socket.id)` to find the connection
     - If found, check if this socketId is still the CURRENT socketId for that clientId (it might be stale if a new connection already replaced it)
     - If it IS the current socketId (meaning no reconnection happened), proceed with leave logic as before
     - If it's NOT the current socketId (meaning a newer connection exists), do nothing — the grace period handler will clean up
     - Call `roomManager.removeConnection(clientId)` when actually removing the user

2. **backend/src/server.ts** — No structural changes needed. The disconnect handler in roomHandlers.ts already handles the logic. Just verify the connection event still registers handlers correctly.
  </action>
  <verify>
Run `cd D:\Codespace\musesync && yarn workspace backend type-check` to verify TypeScript compilation. Check that:
- `room:rejoin` handler exists and sends `room:state_snapshot`
- `room:create` and `room:join` call `handleReconnection`
- Disconnect handler uses `findConnectionBySocketId` instead of scanning all rooms
  </verify>
  <done>Room handlers use clientId-based connection tracking. Rejoin handler sends full state snapshot. Disconnect handler correctly distinguishes stale sockets from actual disconnections. Grace period prevents premature user removal during reconnection.</done>
</task>

</tasks>

<verification>
- `yarn workspace backend type-check` passes with no errors
- `entities.ts` User interface has `clientId: string` field
- `socket-events.ts` has `RoomRejoinRequest`, `RoomStateSnapshot`, and `room:rejoin`/`room:state_snapshot` in SocketEvents
- `RoomManager.ts` has `clientConnections` Map and grace period logic
- `roomHandlers.ts` has `room:rejoin` handler that emits `room:state_snapshot`
- Disconnect handler uses clientId mapping, not room scan by socket.id
</verification>

<success_criteria>
Server tracks users by persistent clientId. Reconnection with same clientId updates socket mapping with 2.5s grace period for old socket. Full state snapshot is sent on rejoin. Batch reconnection window (3s) prevents broadcast storms. Disconnect handler correctly handles stale vs current sockets.
</success_criteria>

<output>
After completion, create `.planning/phases/01-bug-fixes-foundation/01-02-SUMMARY.md`
</output>
