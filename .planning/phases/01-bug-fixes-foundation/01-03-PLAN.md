---
phase: 01-bug-fixes-foundation
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - app/src/services/sync/SocketManager.ts
  - app/src/services/sync/RoomService.ts
  - app/src/components/common/ConnectionStatus.tsx
  - app/src/screens/RoomScreen.tsx
autonomous: false

must_haves:
  truths:
    - "Client generates and persists a UUID on first launch, sends it with every connection"
    - "On reconnection, client emits room:rejoin with clientId and applies state snapshot"
    - "Playback controls are disabled during reconnection with visible 'Reconnecting...' status"
    - "User operations during reconnection are discarded (not queued)"
    - "After reconnection, client overwrites local state with server snapshot"
  artifacts:
    - path: "app/src/services/sync/SocketManager.ts"
      provides: "Persistent clientId generation/storage, reconnection state tracking, rejoin flow"
      contains: "getOrCreateClientId"
    - path: "app/src/services/sync/RoomService.ts"
      provides: "rejoinRoom method using clientId, createRoom/joinRoom send clientId"
      contains: "rejoinRoom"
    - path: "app/src/components/common/ConnectionStatus.tsx"
      provides: "Reconnecting state with 'ÈáçËøû‰∏≠...' label"
      contains: "reconnecting"
    - path: "app/src/screens/RoomScreen.tsx"
      provides: "Disabled controls during reconnection, state snapshot handler, reconnect overlay"
      contains: "room:state_snapshot"
  key_links:
    - from: "app/src/services/sync/SocketManager.ts"
      to: "@react-native-async-storage/async-storage"
      via: "AsyncStorage.getItem/setItem for clientId persistence"
      pattern: "AsyncStorage"
    - from: "app/src/services/sync/RoomService.ts"
      to: "app/src/services/sync/SocketManager.ts"
      via: "socketManager.getClientId() for rejoin requests"
      pattern: "getClientId"
    - from: "app/src/screens/RoomScreen.tsx"
      to: "app/src/services/sync/SocketManager.ts"
      via: "connectionState listener for disabling controls"
      pattern: "onStateChange"
---

<objective>
Fix BUGF-02 client-side: Implement persistent client UUID, reconnection flow with room:rejoin, state snapshot application, and UI feedback during reconnection (disabled controls + status indicator).

Purpose: Client must send persistent clientId so server can identify reconnecting users. During reconnection, controls must be disabled and user operations discarded per user decision. After reconnection, server state overwrites local state.
Output: Seamless client reconnection experience with clear UI feedback.
</objective>

<execution_context>
@C:/Users/MiaowFISH/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/MiaowFISH/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-bug-fixes-foundation/01-RESEARCH.md
@.planning/phases/01-bug-fixes-foundation/01-01-SUMMARY.md
@.planning/phases/01-bug-fixes-foundation/01-02-SUMMARY.md

@app/src/services/sync/SocketManager.ts
@app/src/services/sync/RoomService.ts
@app/src/components/common/ConnectionStatus.tsx
@app/src/screens/RoomScreen.tsx
@shared/types/socket-events.ts
@shared/types/entities.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add persistent clientId to SocketManager and update RoomService with rejoin flow</name>
  <files>app/src/services/sync/SocketManager.ts, app/src/services/sync/RoomService.ts</files>
  <action>
1. **app/src/services/sync/SocketManager.ts** ‚Äî Add persistent clientId and reconnection state:
   - Import `AsyncStorage` from `@react-native-async-storage/async-storage`
   - Import `Platform` is already imported
   - Add a `uuid` generation function (use `crypto.randomUUID()` if available, otherwise implement a simple v4 UUID generator using `Math.random()` ‚Äî do NOT add uuid package to app since it's a React Native app and crypto.randomUUID may not be available on all platforms. Use a simple fallback: `'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, ...)` pattern).
   - Add private field `clientId: string | null = null`
   - Add private field `isReconnecting: boolean = false`
   - Add private field `currentRoomId: string | null = null` and `currentUserId: string | null = null` (to know which room to rejoin)
   - Add `ConnectionState` type: add `'reconnecting'` to the existing union type (currently `'disconnected' | 'connecting' | 'connected' | 'error'`)

   - Add async method `getOrCreateClientId(): Promise<string>`:
     - If `this.clientId` is already set, return it
     - Try `AsyncStorage.getItem('musesync:client_id')`
     - If found, cache in `this.clientId` and return
     - If not found, generate UUID, store via `AsyncStorage.setItem('musesync:client_id', id)`, cache and return

   - Add method `getClientId(): string | null` ‚Äî returns cached clientId (synchronous)

   - Add method `setCurrentRoom(roomId: string, userId: string): void` ‚Äî stores current room context for auto-rejoin

   - Add method `clearCurrentRoom(): void` ‚Äî clears room context (called on explicit leave)

   - Add method `getIsReconnecting(): boolean` ‚Äî returns isReconnecting state

   - Update `setupEventHandlers`:
     - On `'reconnect'` event (Socket.io fires this after successful reconnection): set `isReconnecting = true`, set state to `'reconnecting'`, then if `currentRoomId` and `currentUserId` and `clientId` are set, emit `'room:rejoin'` with `{ roomId: currentRoomId, userId: currentUserId, clientId, username: '', deviceId: '', deviceType: Platform.OS }`. On callback success, set `isReconnecting = false`, set state to `'connected'`. On callback failure or timeout (5s), set `isReconnecting = false`, set state to `'error'`.
     - On `'disconnect'` event: if reason is NOT `'io client disconnect'` (i.e., not intentional), set state to `'reconnecting'` instead of `'disconnected'` to indicate auto-reconnect is in progress.

   - Update `disconnect()` method: call `clearCurrentRoom()` since this is intentional disconnect.

2. **app/src/services/sync/RoomService.ts** ‚Äî Send clientId with all requests, add rejoinRoom:
   - Import `socketManager` is already imported. Use `socketManager.getClientId()` and `socketManager.getOrCreateClientId()`.

   - Update `createRoom`: before emitting, `await socketManager.getOrCreateClientId()`. Add `clientId: socketManager.getClientId()!` to the request object. After success, call `socketManager.setCurrentRoom(roomId, params.userId)`.

   - Update `joinRoom`: same pattern ‚Äî ensure clientId, add to request, call `setCurrentRoom` on success.

   - Add `rejoinRoom` method (used for manual rejoin if auto-rejoin fails):
     ```typescript
     async rejoinRoom(params: { roomId: string; userId: string; username: string; deviceId: string; deviceType: ... }): Promise<{ success: boolean; room?: Room; error?: string }>
     ```
     - Ensure clientId via `getOrCreateClientId()`
     - Emit `'room:rejoin'` with clientId included
     - On success, call `setCurrentRoom`, start time sync
     - Return result

   - Update `leaveRoom`: call `socketManager.clearCurrentRoom()` before emitting leave.
  </action>
  <verify>
Run `cd D:\Codespace\musesync && yarn workspace app exec tsc --noEmit` (or the app's type-check script if available). If no type-check script, verify by reading the files and checking imports resolve. Check that:
- `SocketManager` has `getOrCreateClientId`, `getClientId`, `setCurrentRoom`, `clearCurrentRoom`
- `ConnectionState` includes `'reconnecting'`
- `RoomService.createRoom` and `joinRoom` include `clientId` in request
- `RoomService.rejoinRoom` method exists
  </verify>
  <done>Client generates persistent UUID stored in AsyncStorage. All room requests include clientId. Auto-rejoin fires on Socket.io reconnection. RoomService has explicit rejoinRoom method. Connection state includes 'reconnecting' for UI feedback.</done>
</task>

<task type="auto">
  <name>Task 2: Update ConnectionStatus and RoomScreen for reconnection UI feedback</name>
  <files>app/src/components/common/ConnectionStatus.tsx, app/src/screens/RoomScreen.tsx</files>
  <action>
1. **app/src/components/common/ConnectionStatus.tsx** ‚Äî Add reconnecting state:
   - Add case for `'reconnecting'` in `getStatusConfig`:
     ```
     case 'reconnecting':
       return { color: '#FF9800', label: 'ÈáçËøû‰∏≠...', icon: 'üü°' };
     ```
   - Update the `ConnectionState` import to include the new type

2. **app/src/screens/RoomScreen.tsx** ‚Äî Disable controls during reconnection, handle state snapshot:
   - Add `isReconnecting` state: `const [isReconnecting, setIsReconnecting] = useState(false)`

   - Update connection state listener: when state is `'reconnecting'`, set `isReconnecting = true`. When state is `'connected'`, set `isReconnecting = false`.

   - Add `room:state_snapshot` socket listener:
     - When received, overwrite local room state completely: `setRoom(snapshot.room)`, `roomStore.setRoom(snapshot.room)`, `roomStore.updateSyncState(snapshot.syncState)`
     - Apply playback state from snapshot: if playing, load track and seek to position; if paused, load track, seek, and pause. Use the same track-loading logic already in the `sync:state` handler but with snapshot data.
     - This is the "server state overwrites client" per user decision.

   - Add reconnection overlay: when `isReconnecting` is true, render a semi-transparent overlay on top of the room content with "ÈáçËøû‰∏≠..." text. This provides clear visual feedback.

   - Disable interactive elements during reconnection:
     - Add `disabled={isReconnecting}` or `pointerEvents={isReconnecting ? 'none' : 'auto'}` to the main content ScrollView
     - The "ÊêúÁ¥¢Èü≥‰πê" button, "ÊâìÂºÄÊí≠ÊîæÂô®" button, control mode toggle, and transfer host button should all be non-interactive during reconnection
     - Per user decision: operations during reconnection are discarded, not queued. The disabled UI prevents users from thinking their actions are being processed.

   - Update the `emit` calls in SyncService/RoomScreen: the existing `socketManager.emit` already checks `socket?.connected` and returns early if not connected, so operations during disconnect are already silently dropped. The UI disable is the user-facing part of this requirement.

   - Clean up `room:state_snapshot` listener in the useEffect cleanup function.
  </action>
  <verify>
Run type-check if available. Visually inspect that:
- `ConnectionStatus.tsx` handles `'reconnecting'` state with orange color and 'ÈáçËøû‰∏≠...' label
- `RoomScreen.tsx` has `room:state_snapshot` listener that overwrites local state
- `RoomScreen.tsx` disables controls when `isReconnecting` is true
- `RoomScreen.tsx` shows reconnection overlay
  </verify>
  <done>ConnectionStatus shows 'ÈáçËøû‰∏≠...' during reconnection. RoomScreen disables all controls during reconnection with visual overlay. State snapshot from server overwrites local state on reconnection. User operations during reconnection are effectively discarded (controls disabled + emit guards).</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Manual verification of Phase 1 bug fixes and regression testing</name>
  <files>none</files>
  <action>
Verify all Phase 1 fixes work correctly on real devices/browsers. This is a human verification checkpoint.

What was built:
- BUGF-01: Version number no longer resets to 0 on track change (always increments, wraps at 2^50)
- BUGF-02: Persistent clientId replaces socket.id for user identification, grace period on reconnection, full state snapshot on rejoin, disabled controls during reconnection
- Track change debouncing (300ms leading edge)
- Batch reconnection window (3s) to prevent broadcast storms

How to verify ‚Äî start the backend server and open the app on two devices/browsers:

BUGF-01 Verification (Version Persistence):
1. Create a room, play a track ‚Äî note version in server logs (should be 1, then increment)
2. Pause ‚Äî version should increment (not reset)
3. Change track (next) ‚Äî version should increment (NOT reset to 0)
4. Change track again ‚Äî version should continue incrementing
5. Seek ‚Äî version should increment
6. Verify both clients receive correct, incrementing version numbers

BUGF-02 Verification (Reconnection):
1. Join room from 2 devices
2. On device A, enable airplane mode (or disconnect network)
3. Verify device A shows "ÈáçËøû‰∏≠..." status and controls are disabled
4. Re-enable network on device A
5. Verify device A rejoins successfully (no duplicate in member list)
6. Verify device A receives current playback state (position, playing/paused)
7. Verify device B sees device A as still connected (not a new join)

Regression Tests:
1. Play/pause sync across 2 devices
2. Seek sync across 2 devices
3. Track change sync across 2 devices

Edge Cases:
1. Rapidly press next track 3-4 times quickly ‚Äî should only process one change
2. Try clicking buttons during "ÈáçËøû‰∏≠..." state ‚Äî should be non-interactive
  </action>
  <verify>All checklist items pass on real devices/browsers.</verify>
  <done>All BUGF-01 and BUGF-02 verification scenarios pass. Core sync features (play/pause/seek/track change) work without regression. Edge cases handled correctly.</done>
</task>

</tasks>

<verification>
- App type-check passes (or no type errors in modified files)
- SocketManager generates and persists clientId in AsyncStorage
- RoomService sends clientId with create/join/rejoin requests
- ConnectionStatus shows 'ÈáçËøû‰∏≠...' during reconnection
- RoomScreen disables controls during reconnection
- RoomScreen handles room:state_snapshot by overwriting local state
- All BUGF-01 and BUGF-02 verification scenarios pass manually
</verification>

<success_criteria>
Socket reconnection completes without ID race conditions. Client sends persistent clientId. Controls are disabled during reconnection with clear visual feedback. Server state overwrites client state on reconnection. No duplicate members after reconnection. Existing sync features (play/pause/seek/track change) continue working without regression.
</success_criteria>

<output>
After completion, create `.planning/phases/01-bug-fixes-foundation/01-03-SUMMARY.md`
</output>
