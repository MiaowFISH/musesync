---
phase: 03-background-playback-network-recovery
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/src/services/sync/StateReconciler.ts
  - app/src/services/sync/StaleStateValidator.ts
  - backend/src/services/sync/SyncEngine.ts
  - shared/types/socket-events.ts
autonomous: true

must_haves:
  truths:
    - "State older than 60s is rejected and not applied to client"
    - "Foreground-return and network-reconnection share the same reconciliation logic"
    - "Server disconnects clients that miss heartbeat for >60s"
    - "Reconciliation detects track changes, position drift, and play/pause state differences"
  artifacts:
    - path: "app/src/services/sync/StateReconciler.ts"
      provides: "Shared state reconciliation logic for foreground-return and network-reconnection"
      exports: ["StateReconciler", "stateReconciler", "ReconciliationResult"]
    - path: "app/src/services/sync/StaleStateValidator.ts"
      provides: "Stale state rejection using TimeSyncService clock offset"
      exports: ["isStateStale", "validateState"]
    - path: "backend/src/services/sync/SyncEngine.ts"
      provides: "Enhanced heartbeat with configurable timeout enforcement"
    - path: "shared/types/socket-events.ts"
      provides: "room:state_snapshot request/response types for fetching authoritative room state"
  key_links:
    - from: "app/src/services/sync/StateReconciler.ts"
      to: "app/src/services/sync/StaleStateValidator.ts"
      via: "validates state freshness before applying"
      pattern: "validateState|isStateStale"
    - from: "app/src/services/sync/StaleStateValidator.ts"
      to: "app/src/services/sync/TimeSyncService.ts"
      via: "uses clock offset for accurate timestamp comparison"
      pattern: "timeSyncService\\.getServerTime"
    - from: "app/src/services/sync/StateReconciler.ts"
      to: "shared/types/socket-events.ts"
      via: "uses room:state_snapshot event to fetch authoritative state"
      pattern: "room:state_snapshot"
---

<objective>
Create the shared state reconciliation foundation that both foreground-return and network-reconnection will use.

Purpose: Per user decision, "断线和回前台的同步逻辑应该复用同一套机制" — the sync logic for disconnection recovery and foreground return must be the same mechanism. This plan builds that shared mechanism plus stale state rejection (NETR-04) and server-side heartbeat enforcement (NETR-05).

Output: StateReconciler service, StaleStateValidator, enhanced server heartbeat, room:state_snapshot event type
</objective>

<execution_context>
@C:/Users/MiaowFISH/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/MiaowFISH/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@app/src/services/sync/SocketManager.ts
@app/src/services/sync/TimeSyncService.ts
@app/src/services/sync/SyncService.ts
@app/src/services/sync/RoomService.ts
@app/src/stores/index.tsx
@backend/src/services/sync/SyncEngine.ts
@backend/src/handlers/syncHandlers.ts
@shared/types/socket-events.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Stale state validator + room:state_snapshot event types</name>
  <files>
    app/src/services/sync/StaleStateValidator.ts
    shared/types/socket-events.ts
  </files>
  <action>
1. Create `app/src/services/sync/StaleStateValidator.ts`:
   - Import `timeSyncService` from `./TimeSyncService`
   - `STALE_THRESHOLD_MS = 60 * 1000` (60 seconds per NETR-04)
   - `isStateStale(serverTimestamp: number): boolean` — compares serverTimestamp against `timeSyncService.getServerTime()`, returns true if age > STALE_THRESHOLD_MS
   - `validateState(serverTimestamp: number): { valid: boolean; ageMs: number; reason?: string }` — returns validation result with age info
   - Export both functions

2. Add to `shared/types/socket-events.ts`:
   - `RoomStateSnapshotRequest`: `{ roomId: string; userId: string }`
   - `RoomStateSnapshotResponse`: `{ success: boolean; room?: Room; syncState?: SyncState; playlist?: Track[]; currentTrackIndex?: number; loopMode?: 'none' | 'queue'; serverTimestamp: number; error?: string }`
   - Add `'room:state_snapshot'` to the SocketEvents interface with request/response types
   - Keep all existing types intact
  </action>
  <verify>
    TypeScript compilation: `cd D:/Codespace/musesync && npx tsc --noEmit -p shared/tsconfig.json` passes without errors related to new types.
  </verify>
  <done>
    StaleStateValidator correctly uses TimeSyncService offset for accurate age calculation. room:state_snapshot types are defined in shared types.
  </done>
</task>

<task type="auto">
  <name>Task 2: StateReconciler service + server heartbeat enforcement</name>
  <files>
    app/src/services/sync/StateReconciler.ts
    backend/src/services/sync/SyncEngine.ts
    backend/src/handlers/syncHandlers.ts
    backend/src/handlers/roomHandlers.ts
  </files>
  <action>
1. Create `app/src/services/sync/StateReconciler.ts`:
   - Singleton class `StateReconciler`
   - Private `syncLock: boolean = false` to prevent concurrent reconciliation (pitfall 3: race condition between AppState and network events)
   - `async reconcile(params: { roomId: string; userId: string; source: 'foreground' | 'reconnection' }): Promise<ReconciliationResult>`:
     - If syncLock is true, return `{ skipped: true, reason: 'sync in progress' }`
     - Set syncLock = true in try/finally
     - Emit `room:state_snapshot` via socketManager to fetch authoritative room state
     - Call `validateState(response.serverTimestamp)` — if stale, log warning and return `{ applied: false, reason: 'stale state' }`
     - Compare fetched state against current local state to detect changes:
       - `trackChanged`: different trackId or currentTrackIndex
       - `positionDrift`: abs(serverPosition - localPosition) > 3 seconds
       - `playStateChanged`: playing vs paused mismatch
       - `queueChanged`: playlist length or order differs
     - Return `ReconciliationResult` with: `{ applied: true, changes: { trackChanged, positionDrift, playStateChanged, queueChanged }, newState, toastMessage?: string }`
     - Toast message logic (per user decision): if trackChanged, message = `房间已切到第${index+1}首`; if playStateChanged, message = `房间已${playing ? '继续播放' : '暂停'}`
   - Export `ReconciliationResult` type, `stateReconciler` singleton

2. Enhance `backend/src/services/sync/SyncEngine.ts`:
   - Change `HEARTBEAT_INTERVAL` from 300000 (5min) to 30000 (30s) for more responsive timeout detection
   - Change `MEMBER_TIMEOUT` from 600000 (10min) to 60000 (60s) per NETR-05 requirement
   - In `checkMemberTimeout()`: when member times out, emit `member:disconnected` event (not just `member:timeout`) and call `roomManager.removeMember()` to actually clean up
   - Add `resetHeartbeat(roomId: string, userId: string)` method that resets the timer when heartbeat is received (call from heartbeat handler)

3. Add `room:state_snapshot` handler in `backend/src/handlers/roomHandlers.ts` (or syncHandlers.ts, whichever handles room state queries):
   - On `room:state_snapshot` request: look up room via roomManager, return full room state including syncState, playlist, currentTrackIndex, loopMode, and serverTimestamp
   - Update member activity timestamp on snapshot request

4. In `backend/src/handlers/syncHandlers.ts`, in the `sync:heartbeat` handler:
   - Call `syncEngine.updateMemberActivity(data.roomId, data.fromUserId)` to reset heartbeat timer
   - Also call `syncEngine.resetHeartbeat(data.roomId, data.fromUserId)` if the method exists
  </action>
  <verify>
    TypeScript compilation passes for both app and backend. StateReconciler can be imported and instantiated. Server heartbeat timeout is 60s.
  </verify>
  <done>
    StateReconciler provides a single reconciliation entry point with sync lock, stale state rejection, and change detection. Server enforces 60s heartbeat timeout and disconnects inactive clients. room:state_snapshot endpoint returns authoritative room state.
  </done>
</task>

</tasks>

<verification>
- `StaleStateValidator.isStateStale()` returns true for timestamps older than 60s (adjusted by TimeSyncService offset)
- `StateReconciler.reconcile()` fetches room state, validates freshness, detects changes, and returns structured result
- Sync lock prevents concurrent reconciliation attempts
- Server heartbeat timeout is 60s (NETR-05)
- `room:state_snapshot` handler returns complete room state
</verification>

<success_criteria>
- StateReconciler is importable and provides reconcile() method
- StaleStateValidator correctly rejects state older than 60s using synced time
- Server disconnects clients after 60s of inactivity
- room:state_snapshot event is handled server-side and returns authoritative state
- No TypeScript compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-background-playback-network-recovery/03-01-SUMMARY.md`
</output>
