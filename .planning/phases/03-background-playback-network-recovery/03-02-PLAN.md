---
phase: 03-background-playback-network-recovery
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - app/src/services/lifecycle/AppLifecycleManager.ts
  - app/src/hooks/useAppLifecycle.ts
  - app/src/services/audio/NativeAudioService.ts
  - app/src/hooks/useQueueSync.ts
  - app/src/screens/PlayerScreen.tsx
  - app/src/stores/index.tsx
autonomous: true

must_haves:
  truths:
    - "Music continues playing when app moves to background on iOS and Android"
    - "Lock screen shows play/pause, skip next, skip previous, and seekable progress bar"
    - "Lock screen displays song title, artist name, and cover art"
    - "App does NOT respond to room sync events while backgrounded (independent playback)"
    - "App automatically fetches and applies room state when returning to foreground"
    - "Toast notification shows what changed when returning to foreground (e.g. '房间已切到第3首')"
    - "Queue end behavior follows loop mode: queue-loop restarts, none stops"
  artifacts:
    - path: "app/src/services/lifecycle/AppLifecycleManager.ts"
      provides: "AppState listener that pauses sync in background and triggers reconciliation on foreground"
      exports: ["AppLifecycleManager", "appLifecycleManager"]
    - path: "app/src/hooks/useAppLifecycle.ts"
      provides: "React hook that wires AppLifecycleManager to component tree and applies reconciliation results"
      exports: ["useAppLifecycle"]
  key_links:
    - from: "app/src/services/lifecycle/AppLifecycleManager.ts"
      to: "app/src/services/sync/StateReconciler.ts"
      via: "calls reconcile() on foreground return"
      pattern: "stateReconciler\\.reconcile"
    - from: "app/src/services/lifecycle/AppLifecycleManager.ts"
      to: "app/src/services/sync/SocketManager.ts"
      via: "pauses/resumes sync event processing"
      pattern: "socketManager"
    - from: "app/src/hooks/useAppLifecycle.ts"
      to: "app/src/services/lifecycle/AppLifecycleManager.ts"
      via: "subscribes to lifecycle events and applies state changes"
      pattern: "appLifecycleManager"
---

<objective>
Implement background playback independence and foreground state reconciliation.

Purpose: Per user decisions — music plays independently in background (不响应房间同步事件), and on foreground return, app auto-syncs room state with Toast notification and smooth UI transitions. Lock screen must show play/pause + prev/next + progress bar + song info + cover art.

Output: AppLifecycleManager service, useAppLifecycle hook, enhanced lock screen controls with skip support
</objective>

<execution_context>
@C:/Users/MiaowFISH/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/MiaowFISH/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-background-playback-network-recovery/03-01-SUMMARY.md
@app/src/services/sync/StateReconciler.ts
@app/src/services/sync/SocketManager.ts
@app/src/services/audio/NativeAudioService.ts
@app/src/services/audio/AudioService.ts
@app/src/hooks/usePlayer.ts
@app/src/hooks/useQueueSync.ts
@app/src/stores/index.tsx
@app/src/screens/PlayerScreen.tsx
@app/src/components/common/Toast.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: AppLifecycleManager + useAppLifecycle hook</name>
  <files>
    app/src/services/lifecycle/AppLifecycleManager.ts
    app/src/hooks/useAppLifecycle.ts
  </files>
  <action>
1. Create `app/src/services/lifecycle/AppLifecycleManager.ts`:
   - Import `AppState, AppStateStatus` from `react-native`
   - Import `stateReconciler` from `../sync/StateReconciler`
   - Import `socketManager` from `../sync/SocketManager`
   - Class `AppLifecycleManager`:
     - Private fields: `isInBackground: boolean = false`, `backgroundTimestamp: number = 0`, `subscription: any = null`, `listeners: Set<(result) => void>`
     - `currentRoomId: string | null = null`, `currentUserId: string | null = null` — set by the hook when room context is available
     - `start()`: subscribe to `AppState.addEventListener('change', ...)`, store subscription for cleanup
     - `stop()`: remove subscription
     - `setRoomContext(roomId: string | null, userId: string | null)`: update room/user context
     - `isBackgrounded(): boolean`: return isInBackground
     - `onReconciliation(listener: (result: ReconciliationResult) => void): () => void`: subscribe to reconciliation results, return unsubscribe
     - Private `handleAppStateChange(nextAppState: AppStateStatus)`:
       - If transitioning from active to background/inactive: call `handleBackground()`
       - If transitioning from background/inactive to active: call `handleForeground()`
     - Private `handleBackground()`:
       - Set `isInBackground = true`, `backgroundTimestamp = Date.now()`
       - Log `[AppLifecycle] Entered background — sync paused`
       - NOTE: Do NOT disconnect socket — just stop processing sync events. The actual "pause sync" is done by checking `isBackgrounded()` in the sync event handlers.
     - Private `async handleForeground()`:
       - Set `isInBackground = false`
       - Log `[AppLifecycle] Returned to foreground`
       - If no room context, return early
       - Call `stateReconciler.reconcile({ roomId, userId, source: 'foreground' })`
       - Notify all listeners with the reconciliation result
   - Export singleton `appLifecycleManager`

2. Create `app/src/hooks/useAppLifecycle.ts`:
   - Import `appLifecycleManager` and `useRoomStore`, `usePlayerStore`, `useConnectionStore`
   - Import `toast` from components/common/Toast
   - Import `audioService` from services/audio/AudioService
   - Import `musicApi` from services/api/MusicApi
   - `useAppLifecycle()`:
     - Get roomId, userId from stores
     - `useEffect` to call `appLifecycleManager.setRoomContext(roomId, userId)` when they change
     - `useEffect` to start/stop lifecycle manager on mount/unmount
     - `useEffect` to subscribe to reconciliation results:
       - On result with `applied: true`:
         - If `changes.trackChanged`: update room store with new state, fetch audio URL for new track, play it. Use `Animated` or `react-native-reanimated` for smooth cover fade transition (per user decision: "UI 更新采用平滑过渡动画")
         - If `changes.positionDrift`: seek to correct position
         - If `changes.playStateChanged`: play or pause accordingly
         - If `changes.queueChanged`: update room store playlist
         - If `toastMessage`: show via `toast.info(toastMessage)`
       - On result with `skipped: true`: log and ignore
     - Return `{ isInBackground: boolean }` for components that need to know
  </action>
  <verify>
    TypeScript compilation passes. AppLifecycleManager can be imported and started. useAppLifecycle hook can be called in a component.
  </verify>
  <done>
    AppLifecycleManager detects foreground/background transitions, triggers StateReconciler on foreground return, and notifies subscribers. useAppLifecycle hook applies reconciliation results (track change, position sync, play state) with Toast notifications.
  </done>
</task>

<task type="auto">
  <name>Task 2: Lock screen skip controls + background sync suppression + wiring</name>
  <files>
    app/src/services/audio/NativeAudioService.ts
    app/src/hooks/useQueueSync.ts
    app/src/screens/PlayerScreen.tsx
    app/src/stores/index.tsx
    app/App.tsx
  </files>
  <action>
1. Enhance `app/src/services/audio/NativeAudioService.ts` for lock screen skip controls:
   - The existing code already calls `setActiveForLockScreen(true)` and `updateLockScreenMetadata()` — verify these work correctly
   - Add `onRemotePlay`, `onRemotePause`, `onRemoteNext`, `onRemotePrevious` callback fields (private, nullable)
   - In `setupStatusListener()` or a new `setupRemoteControlListeners()` method: listen to expo-audio's remote control events if available. expo-audio's AudioPlayer supports `addListener('playbackStatusUpdate', ...)` — check if it also supports remote control events. If expo-audio does not expose remote control events directly, use the `player.paused` state changes from `playbackStatusUpdate` to detect remote play/pause, and expose `onRemoteNext`/`onRemotePrevious` callbacks that will be wired from the queue advance logic.
   - Add public methods: `setOnRemoteNext(cb: () => void)`, `setOnRemotePrevious(cb: () => void)` — these will be called by useQueueSync to wire skip controls to queue advance
   - Update `updateLockScreenMetadata()` call in `play()` to include duration for progress bar display

2. Wire lock screen skip controls in `app/src/hooks/useQueueSync.ts`:
   - Import `audioService` (already imported)
   - In the auto-advance useEffect (or a new useEffect), call `audioService.implementation` (if accessible) or add `setOnRemoteNext`/`setOnRemotePrevious` to AudioService facade
   - `onRemoteNext`: trigger `queueService.advance({ roomId, userId, direction: 'next' })` then `fetchAndPlay(nextTrack)`
   - `onRemotePrevious`: trigger `queueService.advance({ roomId, userId, direction: 'previous' })` then `fetchAndPlay(prevTrack)`
   - Clean up callbacks on unmount

3. Add background sync suppression:
   - In `app/src/stores/index.tsx` RoomProvider's `queue:updated` listener: check `appLifecycleManager.isBackgrounded()` — if true, skip processing the event (per user decision: 后台时不响应房间同步事件)
   - In `app/src/hooks/useQueueSync.ts` toast listener: check `appLifecycleManager.isBackgrounded()` — if true, skip toast

4. Wire `useAppLifecycle` in `app/App.tsx` or a top-level component:
   - Add `useAppLifecycle()` call inside StoreProvider (needs a wrapper component since hooks can't be called in App directly if App doesn't use stores)
   - Create a small `AppLifecycleWatcher` component that calls `useAppLifecycle()` and renders nothing, place it inside StoreProvider in App.tsx

5. Queue end behavior per user decision (队列播完行为：遵循当前循环模式):
   - In `useQueueSync.ts` auto-advance logic, when `result.currentTrackIndex === -1` (queue finished):
     - If loopMode is 'queue': the server should already handle wrapping to index 0. Verify this works.
     - If loopMode is 'none': stop playback, show toast '播放队列已结束' (already implemented)
   - This may already work correctly — verify and fix if needed
  </action>
  <verify>
    - TypeScript compilation passes
    - Lock screen metadata includes title, artist, artwork, duration
    - Background sync suppression: queue:updated events are ignored when app is backgrounded
    - useAppLifecycle is wired in App.tsx
    - `npx tsc --noEmit -p app/tsconfig.json` passes
  </verify>
  <done>
    Lock screen shows play/pause + skip controls + progress bar + song info + cover art. App ignores room sync events while backgrounded. useAppLifecycle is wired at app root level. Queue end behavior follows loop mode.
  </done>
</task>

</tasks>

<verification>
- Background playback: music continues when app is backgrounded (requires device testing)
- Lock screen: shows song title, artist, cover art, play/pause, skip next/prev, progress bar
- Background independence: room sync events (queue:updated, sync:state) are NOT processed while backgrounded
- Foreground return: app fetches latest room state, applies changes, shows Toast notification
- Queue end: follows loop mode (queue-loop restarts from beginning, none stops)
</verification>

<success_criteria>
- AppLifecycleManager correctly detects foreground/background transitions
- Foreground return triggers StateReconciler and applies results with Toast
- Lock screen displays full metadata and skip controls
- Sync events are suppressed during background
- No TypeScript compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-background-playback-network-recovery/03-02-SUMMARY.md`
</output>
