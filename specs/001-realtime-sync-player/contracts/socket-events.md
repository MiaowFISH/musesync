# Socket.io Event Contracts

**Feature**: 001-realtime-sync-player  
**Protocol**: WebSocket (Socket.io v4)  
**Date**: 2026-01-02

## Connection Configuration

```typescript
// Server configuration
const io = new Server(server, {
  cors: { origin: '*', methods: ['GET', 'POST'] },
  pingInterval: 25000, // 25 seconds
  pingTimeout: 60000,  // 60 seconds
  transports: ['websocket', 'polling']
});

// Client configuration
const socket = io('https://api.musictogether.app', {
  transports: ['websocket'],
  reconnection: true,
  reconnectionDelay: 1000,
  reconnectionDelayMax: 5000,
  reconnectionAttempts: 5
});
```

## Event Naming Convention

- **Namespace prefix**: `room:`, `sync:`, `time:`, `error:`
- **Direction**: 
  - Client → Server: imperative (e.g., `room:create`, `sync:play`)
  - Server → Client: past tense (e.g., `room:created`, `sync:updated`)
  - Server → All clients (broadcast): descriptive (e.g., `sync:state`)

---

## Room Management Events

### `room:create`

**Direction**: Client → Server  
**Purpose**: Create a new room and become the host  
**When**: User clicks "Create Room" button

**Request Payload**:
```typescript
{
  userId: string;      // UUID v4 generated by client
  username: string;    // User's display name (1-20 chars)
  deviceId: string;    // Device unique identifier
  deviceType: 'ios' | 'android' | 'web';
}
```

**Response Event**: `room:created`

**Example**:
```typescript
socket.emit('room:create', {
  userId: 'a1b2c3d4-e5f6-7890-abcd-ef1234567890',
  username: '用户1234',
  deviceId: 'iPhone14,3',
  deviceType: 'ios'
});
```

---

### `room:created`

**Direction**: Server → Client  
**Purpose**: Confirm room creation and provide room details  
**When**: Server successfully creates room

**Response Payload**:
```typescript
{
  success: true;
  room: {
    roomId: string;           // 6-digit room code
    hostId: string;           // Creator's userId
    members: User[];          // Initial member list (just the creator)
    playlist: Track[];        // Empty initially
    syncState: SyncState;     // Initial stopped state
    controlMode: 'open';      // Default to open collaboration
    createdAt: number;        // Unix timestamp in ms
  };
}
```

**Error Response**:
```typescript
{
  success: false;
  error: {
    code: 'CREATION_FAILED' | 'RATE_LIMIT_EXCEEDED';
    message: string;
  };
}
```

**Example**:
```typescript
socket.on('room:created', (data) => {
  if (data.success) {
    console.log(`Room created: ${data.room.roomId}`);
    // Navigate to player screen
  }
});
```

---

### `room:join`

**Direction**: Client → Server  
**Purpose**: Join an existing room  
**When**: User enters room code and clicks "Join"

**Request Payload**:
```typescript
{
  roomId: string;      // 6-digit room code
  userId: string;      // UUID v4
  username: string;    // Display name
  deviceId: string;
  deviceType: 'ios' | 'android' | 'web';
}
```

**Response Event**: `room:joined` (unicast to joiner) + `room:member_joined` (broadcast to others)

**Example**:
```typescript
socket.emit('room:join', {
  roomId: '123456',
  userId: 'b2c3d4e5-f6a7-8901-bcde-f12345678901',
  username: '用户5678',
  deviceId: 'SM-G998B',
  deviceType: 'android'
});
```

---

### `room:joined`

**Direction**: Server → Client (unicast to joiner)  
**Purpose**: Confirm successful room join and provide current state  
**When**: User successfully joins room

**Response Payload**:
```typescript
{
  success: true;
  room: {
    roomId: string;
    hostId: string;
    members: User[];          // All current members including joiner
    playlist: Track[];        // Current playlist
    currentTrack: Track | null;
    currentTrackIndex: number;
    syncState: SyncState;     // Current playback state
    controlMode: 'open' | 'host-only';
    createdAt: number;
  };
}
```

**Error Response**:
```typescript
{
  success: false;
  error: {
    code: 'ROOM_NOT_FOUND' | 'ROOM_FULL' | 'INVALID_ROOM_CODE';
    message: string;
  };
}
```

---

### `room:member_joined`

**Direction**: Server → All clients in room (broadcast, except joiner)  
**Purpose**: Notify existing members of new member  
**When**: User joins room

**Payload**:
```typescript
{
  user: User;              // Newly joined user
  totalMembers: number;    // Updated member count
}
```

**Example**:
```typescript
socket.on('room:member_joined', (data) => {
  console.log(`${data.user.username} joined (${data.totalMembers} total)`);
  // Update UI member list
});
```

---

### `room:leave`

**Direction**: Client → Server  
**Purpose**: Leave the current room  
**When**: User clicks "Leave Room" or closes app

**Request Payload**:
```typescript
{
  roomId: string;
  userId: string;
}
```

**Response Event**: `room:left` (unicast) + `room:member_left` (broadcast)

---

### `room:member_left`

**Direction**: Server → All clients in room (broadcast)  
**Purpose**: Notify members that someone left  
**When**: User leaves room or disconnects

**Payload**:
```typescript
{
  userId: string;          // Who left
  username: string;
  totalMembers: number;    // Updated member count
  newHostId?: string;      // If host left, new host userId
}
```

**Example**:
```typescript
socket.on('room:member_left', (data) => {
  console.log(`${data.username} left (${data.totalMembers} remaining)`);
  if (data.newHostId) {
    console.log(`Host transferred to user ${data.newHostId}`);
  }
});
```

---

### `room:control_mode_changed`

**Direction**: Server → All clients in room (broadcast)  
**Purpose**: Notify control mode change (open ↔ host-only)  
**When**: Host toggles control mode

**Payload**:
```typescript
{
  controlMode: 'open' | 'host-only';
  changedBy: string;       // Host userId
}
```

---

## Sync & Playback Events

### `sync:play`

**Direction**: Client → Server  
**Purpose**: Start playback of a track  
**When**: User clicks play button, or system auto-plays next track

**Request Payload**:
```typescript
{
  roomId: string;
  userId: string;          // Who initiated play
  trackId: string;         // Track to play
  seekTime: number;        // Start position in ms (0 for beginning)
}
```

**Response Event**: `sync:state` (broadcast to all)

**Example**:
```typescript
socket.emit('sync:play', {
  roomId: '123456',
  userId: currentUserId,
  trackId: '33894312',
  seekTime: 0
});
```

---

### `sync:pause`

**Direction**: Client → Server  
**Purpose**: Pause current playback  
**When**: User clicks pause button

**Request Payload**:
```typescript
{
  roomId: string;
  userId: string;
  seekTime: number;        // Current position when paused
}
```

**Response Event**: `sync:state` (broadcast)

---

### `sync:seek`

**Direction**: Client → Server  
**Purpose**: Jump to specific position in track  
**When**: User drags progress bar

**Request Payload**:
```typescript
{
  roomId: string;
  userId: string;
  seekTime: number;        // Target position in ms
}
```

**Response Event**: `sync:state` (broadcast)

---

### `sync:next` / `sync:previous`

**Direction**: Client → Server  
**Purpose**: Skip to next/previous track in playlist  
**When**: User clicks next/previous button

**Request Payload**:
```typescript
{
  roomId: string;
  userId: string;
}
```

**Response Event**: `sync:state` (broadcast with new track)

---

### `sync:state`

**Direction**: Server → All clients in room (broadcast)  
**Purpose**: Broadcast authoritative playback state  
**When**: Any playback state change (play, pause, seek, track change)

**Payload**:
```typescript
{
  roomId: string;
  syncState: {
    trackId: string | null;
    status: 'playing' | 'paused' | 'loading' | 'stopped';
    seekTime: number;          // Position in ms
    serverTimestamp: number;   // Unix timestamp when state was set
    playbackRate: number;      // 1.0 (never sent as modified value)
    volume: number;            // Room-level volume
    updatedBy: string;         // userId who triggered change
    version: number;           // Incremented version
  };
  currentTrack: Track | null;  // Full track object (if changed)
}
```

**Example**:
```typescript
socket.on('sync:state', (data) => {
  // Calculate expected playback position
  const currentServerTime = Date.now() + localTimeOffset;
  const elapsedTime = currentServerTime - data.syncState.serverTimestamp;
  const expectedPosition = data.syncState.seekTime + elapsedTime;
  
  // Apply state to player
  if (data.syncState.status === 'playing') {
    audioPlayer.play();
    audioPlayer.seekTo(expectedPosition);
  } else if (data.syncState.status === 'paused') {
    audioPlayer.pause();
    audioPlayer.seekTo(data.syncState.seekTime);
  }
});
```

---

### `sync:playlist_add`

**Direction**: Client → Server  
**Purpose**: Add track to playlist  
**When**: User searches and adds a song

**Request Payload**:
```typescript
{
  roomId: string;
  userId: string;
  track: Track;            // Full track object (from NetEase API)
}
```

**Response Event**: `sync:playlist_updated` (broadcast)

---

### `sync:playlist_remove`

**Direction**: Client → Server  
**Purpose**: Remove track from playlist  
**When**: User long-presses and deletes a song

**Request Payload**:
```typescript
{
  roomId: string;
  userId: string;
  trackId: string;
}
```

**Response Event**: `sync:playlist_updated` (broadcast)

---

### `sync:playlist_reorder`

**Direction**: Client → Server  
**Purpose**: Change track order in playlist  
**When**: User drags to reorder songs

**Request Payload**:
```typescript
{
  roomId: string;
  userId: string;
  fromIndex: number;       // Original position
  toIndex: number;         // New position
}
```

**Response Event**: `sync:playlist_updated` (broadcast)

---

### `sync:playlist_updated`

**Direction**: Server → All clients in room (broadcast)  
**Purpose**: Notify playlist changes  
**When**: Playlist add/remove/reorder

**Payload**:
```typescript
{
  roomId: string;
  playlist: Track[];        // Full updated playlist
  currentTrackIndex: number;
  updatedBy: string;
}
```

---

## Time Synchronization Events

### `time:sync_request`

**Direction**: Client → Server  
**Purpose**: Request time synchronization  
**When**: On connect, then every 30 seconds

**Request Payload**:
```typescript
{
  clientTimestamp: number;  // Client's Date.now() when sent
}
```

**Response Event**: `time:sync_response`

---

### `time:sync_response`

**Direction**: Server → Client (unicast)  
**Purpose**: Provide server timestamps for offset calculation  
**When**: Response to `time:sync_request`

**Payload**:
```typescript
{
  clientTimestamp: number;      // Echo of client's original timestamp
  serverReceiveTime: number;    // When server received request
  serverSendTime: number;       // When server sent response
}
```

**Client Calculation**:
```typescript
socket.on('time:sync_response', (data) => {
  const t0 = data.clientTimestamp;
  const t1 = data.serverReceiveTime;
  const t2 = data.serverSendTime;
  const t3 = Date.now();
  
  const roundTripDelay = (t3 - t0);
  const serverTime = t2 + roundTripDelay / 2;
  const offset = serverTime - t3;
  
  // Store offset for use in sync calculations
  localTimeOffset = offset;
});
```

---

## Error Events

### `error:permission_denied`

**Direction**: Server → Client (unicast)  
**Purpose**: Notify operation not permitted  
**When**: Non-host tries to control in host-only mode

**Payload**:
```typescript
{
  operation: string;       // e.g., 'sync:play', 'sync:pause'
  reason: 'HOST_ONLY_MODE' | 'ROOM_FULL' | 'INVALID_STATE';
  message: string;
}
```

---

### `error:rate_limit`

**Direction**: Server → Client (unicast)  
**Purpose**: Notify rate limit exceeded  
**When**: Too many requests in short time

**Payload**:
```typescript
{
  operation: string;
  retryAfter: number;      // Seconds to wait before retry
  message: string;
}
```

---

## Heartbeat & Connection Events

### `ping` / `pong`

**Direction**: Bidirectional (Socket.io built-in)  
**Purpose**: Connection keepalive  
**When**: Every 25 seconds (configurable)

**Handled automatically by Socket.io**, no manual implementation needed.

---

### `disconnect`

**Direction**: Server → Client (Socket.io built-in)  
**Purpose**: Notify client of disconnection  
**When**: Connection lost

**Reasons**:
```typescript
socket.on('disconnect', (reason) => {
  // 'io server disconnect' - server kicked client
  // 'io client disconnect' - client called socket.disconnect()
  // 'ping timeout' - no pong received within pingTimeout
  // 'transport close' - network failure
  // 'transport error' - transport error
});
```

---

## TypeScript Type Definitions

Complete type definitions for Socket.io events:

```typescript
// shared/types/socket-events.ts

export interface SocketEvents {
  // Room management
  'room:create': (data: RoomCreateRequest) => void;
  'room:created': (data: RoomCreatedResponse) => void;
  'room:join': (data: RoomJoinRequest) => void;
  'room:joined': (data: RoomJoinedResponse) => void;
  'room:member_joined': (data: MemberJoinedEvent) => void;
  'room:leave': (data: RoomLeaveRequest) => void;
  'room:member_left': (data: MemberLeftEvent) => void;
  'room:control_mode_changed': (data: ControlModeChangedEvent) => void;

  // Sync & playback
  'sync:play': (data: SyncPlayRequest) => void;
  'sync:pause': (data: SyncPauseRequest) => void;
  'sync:seek': (data: SyncSeekRequest) => void;
  'sync:next': (data: SyncNextRequest) => void;
  'sync:previous': (data: SyncPreviousRequest) => void;
  'sync:state': (data: SyncStateEvent) => void;
  'sync:playlist_add': (data: PlaylistAddRequest) => void;
  'sync:playlist_remove': (data: PlaylistRemoveRequest) => void;
  'sync:playlist_reorder': (data: PlaylistReorderRequest) => void;
  'sync:playlist_updated': (data: PlaylistUpdatedEvent) => void;

  // Time sync
  'time:sync_request': (data: TimeSyncRequest) => void;
  'time:sync_response': (data: TimeSyncResponse) => void;

  // Errors
  'error:permission_denied': (data: PermissionDeniedError) => void;
  'error:rate_limit': (data: RateLimitError) => void;
}

// Request types
export interface RoomCreateRequest {
  userId: string;
  username: string;
  deviceId: string;
  deviceType: 'ios' | 'android' | 'web';
}

export interface RoomJoinRequest {
  roomId: string;
  userId: string;
  username: string;
  deviceId: string;
  deviceType: 'ios' | 'android' | 'web';
}

export interface SyncPlayRequest {
  roomId: string;
  userId: string;
  trackId: string;
  seekTime: number;
}

export interface SyncPauseRequest {
  roomId: string;
  userId: string;
  seekTime: number;
}

export interface SyncSeekRequest {
  roomId: string;
  userId: string;
  seekTime: number;
}

export interface SyncNextRequest {
  roomId: string;
  userId: string;
}

export interface PlaylistAddRequest {
  roomId: string;
  userId: string;
  track: Track;
}

export interface PlaylistRemoveRequest {
  roomId: string;
  userId: string;
  trackId: string;
}

export interface PlaylistReorderRequest {
  roomId: string;
  userId: string;
  fromIndex: number;
  toIndex: number;
}

export interface TimeSyncRequest {
  clientTimestamp: number;
}

// Response/Event types
export interface RoomCreatedResponse {
  success: boolean;
  room?: Room;
  error?: { code: string; message: string };
}

export interface RoomJoinedResponse {
  success: boolean;
  room?: Room;
  error?: { code: string; message: string };
}

export interface MemberJoinedEvent {
  user: User;
  totalMembers: number;
}

export interface MemberLeftEvent {
  userId: string;
  username: string;
  totalMembers: number;
  newHostId?: string;
}

export interface ControlModeChangedEvent {
  controlMode: 'open' | 'host-only';
  changedBy: string;
}

export interface SyncStateEvent {
  roomId: string;
  syncState: SyncState;
  currentTrack: Track | null;
}

export interface PlaylistUpdatedEvent {
  roomId: string;
  playlist: Track[];
  currentTrackIndex: number;
  updatedBy: string;
}

export interface TimeSyncResponse {
  clientTimestamp: number;
  serverReceiveTime: number;
  serverSendTime: number;
}

export interface PermissionDeniedError {
  operation: string;
  reason: 'HOST_ONLY_MODE' | 'ROOM_FULL' | 'INVALID_STATE';
  message: string;
}

export interface RateLimitError {
  operation: string;
  retryAfter: number;
  message: string;
}
```

---

## Message Size Constraints

- Maximum event payload size: 64KB (Socket.io default)
- Track object in `sync:state`: ~1KB (acceptable)
- Playlist with 100 tracks: ~100KB (exceeds limit)
  - **Mitigation**: For large playlists, send `trackIds[]` only, clients fetch full Track data separately

---

## Security Considerations

- **Room ID entropy**: 6 digits = 1,000,000 possible codes, sufficient for 24-hour TTL
- **No authentication**: Fully anonymous, anyone with room code can join
- **Rate limiting**: Max 10 events per second per socket
- **Payload validation**: All incoming events validated against schemas on server

---

**Version**: 1.0.0  
**Generated**: 2026-01-02  
**Next**: Implement Socket.io server handlers in `backend/src/`
